
'use server';
/**
 * @fileOverview A customer support and sales AI agent for UREVENT 360 PLUS.
 *
 * - continueConversation - A function that continues a conversation with the AI.
 * - ConversationInput - The input type for the continueConversation function.
 * - ConversationOutput - The return type for the continueConversation function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';
import { MessageData } from 'genkit';
import { createLeadAction } from '@/app/app/events/new/actions';
import servicesCatalog from '@/lib/services-catalog.json';
import fs from 'fs/promises';
import path from 'path';

const promptFilePath = path.join(process.cwd(), 'src', 'lib', 'ai-system-prompt.txt');
const promptEsFilePath = path.join(process.cwd(), 'src', 'lib', 'ai-system-prompt-es.txt');

const LeadSchema = z.object({
  fullName: z.string().describe("Clientâ€™s full name"),
  phone: z.string().describe("Client phone with country/area code"),
  services: z.array(z.string()).describe("List of service IDs or names from SERVICES_CATALOG"),
  eventDate: z.string().describe("Date in ISO or natural language"),
  location: z.string().describe("City/State or ZIP code"),
  notes: z.string().optional().describe("Any extra preferences captured during chat"),
});


const createLeadTool = ai.defineTool(
    {
        name: 'createLead',
        description: 'Create a new sales lead in the CRM when all five fields are collected.',
        inputSchema: LeadSchema,
        outputSchema: z.object({ success: z.boolean(), message: z.string() }),
    },
    async (input) => {
        console.log(`AI is creating a lead with input:`, input);
        
        const serviceObjects = input.services.map(serviceName => ({
            serviceId: serviceName, 
            title: serviceName,
            qty: 1,
            notes: 'Generated by AI Assistant'
        }));

        try {
            const result = await createLeadAction({
                hostEmail: `lead-via-ai-${Date.now()}@urevent360.com`, 
                name: input.fullName,
                type: 'AI Lead',
                guestCount: 1,
                date: new Date(input.eventDate),
                timeWindow: 'To be determined',
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                venueName: input.location,
                address: input.location,
                city: input.location,
                state: '',
                zip: '',
                onsiteContactName: input.fullName,
                onsiteContactPhone: input.phone,
                notes: input.notes || `Lead generated by AI assistant. Services of interest: ${input.services.join(', ')}`,
                requestedServices: serviceObjects,
            });
            return { success: result.success, message: result.message || (result.success ? 'Lead created successfully.' : 'Failed to create lead.')};
        } catch (error) {
            console.error('Error creating lead from AI tool:', error);
            const errorMessage = error instanceof Error ? error.message : 'An internal error occurred.';
            return { success: false, message: errorMessage };
        }
    }
);


const ConversationInputSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(['user', 'model']),
      content: z.array(z.object({ text: z.string() })),
    })
  ).describe('A history of messages in the conversation.'),
});
export type ConversationInput = z.infer<typeof ConversationInputSchema>;

const ConversationOutputSchema = z.string().describe("The AI's response.");
export type ConversationOutput = z.infer<typeof ConversationOutputSchema>;

// Helper function to detect language from messages
const detectLanguage = (messages: MessageData[]): 'en' | 'es' => {
    const spanishKeywords = ['hola', 'gracias', 'evento', 'precio', 'servicio', 'ayuda'];
    const userText = messages
        .filter(m => m.role === 'user')
        .flatMap(m => m.content)
        .map(c => c?.text || '')
        .join(' ')
        .toLowerCase();
    
    for (const keyword of spanishKeywords) {
        if (userText.includes(keyword)) {
            return 'es';
        }
    }
    return 'en';
}

/**
 * Normalizes a message to the format expected by Genkit's prompt.
 * It ensures 'content' is an array with text parts and handles various legacy formats.
 */
function normalizeMessage(message: any): MessageData | null {
  if (!message || typeof message !== 'object') return null;

  // Filter out tool/function messages that don't have a 'text' part.
  const isConversationalRole = message.role === 'user' || message.role === 'model' || message.role === 'system';
  if (!isConversationalRole) {
      return null;
  }

  const role = message.role;
  const contentParts: { text: string }[] = [];

  const processContentPart = (part: any) => {
    if (typeof part === 'string') {
      const trimmedText = part.trim();
      if (trimmedText) contentParts.push({ text: trimmedText });
    } else if (typeof part === 'object' && part !== null) {
      if (typeof part.text === 'string' && part.text.trim()) {
        contentParts.push({ text: part.text.trim() });
      } else if (part.media && typeof part.media.url === 'string') {
        contentParts.push({ text: `[Attachment: ${part.media.contentType || 'file'}]` });
      }
    }
  };
  
  if (Array.isArray(message.content)) {
    message.content.forEach(processContentPart);
  } else if (typeof message.text === 'string') {
    processContentPart(message.text);
  } else if (Array.isArray(message.parts)) {
    message.parts.forEach(processContentPart);
  } else {
     processContentPart(message.content);
  }

  if (contentParts.length === 0) {
    return null; // Skip messages with no valid textual content
  }

  return { role, content: contentParts };
}


export async function continueConversation(messages: MessageData[]): Promise<ConversationOutput> {
  const normalizedHistory = messages
    .map(normalizeMessage)
    .filter((msg): msg is MessageData => !!msg);

  const limitedHistory = normalizedHistory.slice(-15);

  return customerSupportFlow(limitedHistory);
}


const customerSupportFlow = ai.defineFlow(
  {
    name: 'customerSupportFlow',
    inputSchema: z.array(MessageData),
    outputSchema: z.string(),
  },
  async (messages) => {
    try {
        const lang = detectLanguage(messages);
        
        let systemPromptText = '';
        try {
            const promptFile = lang === 'es' ? promptEsFilePath : promptFilePath;
            systemPromptText = await fs.readFile(promptFile, 'utf-8');
        } catch (e) {
            console.error(`Could not read system prompt file for lang '${lang}'`, e);
            // Use a fallback prompt if file is missing
            systemPromptText = "You are a helpful assistant for UREVENT 360 PLUS.";
        }

        if (systemPromptText.includes('{{SERVICES_CATALOG}}')) {
            systemPromptText = systemPromptText.replace('{{SERVICES_CATALOG}}', JSON.stringify(servicesCatalog, null, 2));
        }

        const prompt = ai.definePrompt({
            name: `customerSupportPrompt-${lang}`,
            system: systemPromptText,
            tools: [createLeadTool],
            inputSchema: z.array(MessageData),
        });
        
        const history = messages.length > 0
          ? messages
          : [{ role: 'user' as const, content: [{ text: 'Hello' }] }];

        // Temporary debug logs
        console.log(`[AI FLOW] Normalization complete. Sending ${history.length} messages to model.`);
        history.forEach((msg, i) => {
            const contentPreview = msg.content[0]?.text?.substring(0, 40) || '[NO TEXT CONTENT]';
            console.log(`[AI FLOW] Message ${i}: Role=${msg.role}, Content='${contentPreview}...'`);
        });

        const { output } = await prompt(history);
        return output?.text || "I'm sorry, I'm having trouble responding right now. Please try again in a moment.";

    } catch (error) {
        console.error("Error in customerSupportFlow:", error);
        return "I'm sorry, I'm having trouble responding right now. Please try again in a moment.";
    }
  }
);
